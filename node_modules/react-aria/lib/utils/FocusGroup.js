'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mitt = require('mitt');

var _mitt2 = _interopRequireDefault(_mitt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FocusGroup = function () {
  function FocusGroup(userOptions) {
    var _this = this;

    _classCallCheck(this, FocusGroup);

    this._handleKeydown = function (e) {
      // only respond to keyboard events when
      // focus is already within the focus-group
      if (_this.getActiveIndex() === -1) return;

      // setTimeout prevents React from grabbing the event immediately after and
      // causing unexpected behaviour like triggering a button that receives focus
      // maybe we can fix this somehow?
      switch (e.keyCode) {
        case 38:
          // ArrowUp
          _this.prev();
          break;
        case 40:
          // ArrowDown
          _this.next();
          break;
        case 36:
          // Home
          _this.first();
          break;
        case 35:
          // End
          _this.last();
          break;
        case 13:
          // Enter
          _this.selectFocusedMember(e);
          break;
        default:
          return;
      }
      // if we've made it here then we can safely preventDefault since it hit a method we wanted
      e.preventDefault();
    };

    var options = _extends({
      rootNode: document,
      members: [],
      initialIndex: 0,
      wrap: true
    }, userOptions);
    var emitter = (0, _mitt2.default)();

    this.on = emitter.on;
    this.emit = emitter.emit;
    this.off = emitter.off;

    this._rootNode = options.rootNode;
    this._members = options.members;
    this._activeIndex = options.initialIndex;
    this._options = options;
  }

  _createClass(FocusGroup, [{
    key: 'activate',
    value: function activate() {
      this._rootNode.addEventListener('keydown', this._handleKeydown, true);
    }
  }, {
    key: 'deactivate',
    value: function deactivate() {
      this._rootNode.removeEventListener('keydown', this._handleKeydown, true);
    }
  }, {
    key: 'setRootNode',
    value: function setRootNode(node) {
      // deactivate, and then reactivate after setting root node so we can
      // attach the proper element to the keydown listener
      this.deactivate();
      this._rootNode = node;
      this.activate();
    }
  }, {
    key: 'addMember',
    value: function addMember(member, index) {
      if (index !== null && index !== undefined) {
        this._members.splice(index, 0, member);
      } else {
        this._members.push(member);
      }
    }
  }, {
    key: 'removeMember',
    value: function removeMember(member) {
      var indexToRemove = isNaN(member) ? this.getMemberIndex(member) : member;

      if (indexToRemove !== -1) {
        this._members.splice(indexToRemove, 1);
      }
    }
  }, {
    key: 'getMembers',
    value: function getMembers() {
      return this._members;
    }
  }, {
    key: 'getMemberIndex',
    value: function getMemberIndex(member) {
      for (var i = 0; i < this._members.length; i++) {
        if (this._members[i].node === member) {
          return i;
        }
      }
      return -1;
    }
  }, {
    key: 'getActiveIndex',
    value: function getActiveIndex() {
      return this._rootNode !== document ? this._activeIndex : this.getMemberIndex(document.activeElement);
    }
  }, {
    key: 'getActiveMember',
    value: function getActiveMember() {
      return this._members[this.getActiveIndex()];
    }
  }, {
    key: 'prev',
    value: function prev() {
      var activeIndex = this.getActiveIndex();
      var targetIndex = activeIndex;
      if (activeIndex > 0) {
        targetIndex = activeIndex - 1;
      } else if (this._options.wrap) {
        targetIndex = this._members.length - 1;
      }
      this.focus(targetIndex);
    }
  }, {
    key: 'next',
    value: function next() {
      var activeIndex = this.getActiveIndex();
      var targetIndex = activeIndex;
      if (activeIndex < this._members.length - 1) {
        targetIndex = activeIndex + 1;
      } else if (this._options.wrap) {
        targetIndex = 0;
      }
      this.focus(targetIndex);
    }
  }, {
    key: 'first',
    value: function first() {
      this.focus(0);
    }
  }, {
    key: 'last',
    value: function last() {
      this.focus(this._members.length - 1);
    }
  }, {
    key: 'focus',
    value: function focus(index) {
      var member = this._members[index];

      if (!member) {
        return;
      }
      if (member.node.focus) {
        member.node.focus();
      } else if (member.node.tagName.toLowerCase() === 'input') {
        member.node.select();
      }

      this._activeIndex = index;

      this.emit('focus', member, index);
    }
  }, {
    key: 'selectFocusedMember',
    value: function selectFocusedMember(e) {
      this.emit('select', this.getActiveMember(), e);
    }
  }]);

  return FocusGroup;
}();

exports.default = FocusGroup;
module.exports = exports['default'];